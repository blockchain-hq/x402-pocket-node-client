/**
 * Pocket Node Client - n8n Node
 * Automatically handles 402 responses and makes USDC payments
 * Features auto-generated wallet
 */

import {
  IExecuteFunctions,
  INodeExecutionData,
  INodeType,
  INodeTypeDescription,
  NodeOperationError,
} from 'n8n-workflow';

import { X402Client, X402Response, generateWallet } from 'x402-client-sdk';
import { Connection, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';

export class PocketNodeClient implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Pocket Node Client',
    name: 'pocketNodeClient',
    icon: 'file:pocket.svg',
    group: ['transform'],
    version: 1,
    subtitle: 'Auto-pay 402 responses',
    description: 'Automatically handles HTTP 402 Payment Required with USDC on Solana',
    defaults: {
      name: 'Pocket Node Client',
    },
    inputs: ['main'],
    outputs: ['main'],
    credentials: [
      {
        name: 'pocketNodeWallet',
        required: false, 
      },
    ],
    properties: [
      {
        displayName: 'No wallet configured? A wallet will be auto-generated. IMPORTANT: Workflow must be SAVED AND ACTIVE for wallet to persist. To get wallet address: 1) Keep workflow active & saved, 2) Select "Get Wallet Info" mode, 3) Check executions to see the output, 4) Fund with SOL & USDC. Or, add Pocket Node Wallet credential.',
        name: 'notice',
        type: 'notice',
        default: '',
      },
      {
        displayName: 'Mode',
        name: 'mode',
        type: 'options',
        noDataExpression: true,
        options: [
          {
            name: 'Auto-Handle 402',
            value: 'autoHandle',
            description: 'Automatically detect and pay for 402 responses',
          },
          {
            name: 'Get Wallet Info',
            value: 'walletInfo',
            description: 'Get wallet address and balance',
          },
        ],
        default: 'autoHandle',
      },
      {
        displayName: 'Reset Auto-Generated Wallet',
        name: 'resetWallet',
        type: 'boolean',
        default: false,
        description: 'If enabled, regenerates the auto-generated wallet stored in this workflow. Use this if you want a fresh wallet or if you lost access to the current one.',
        displayOptions: {
          show: {
            mode: ['walletInfo'],
          },
        },
      },
      {
        displayName: 'Auto-Fund Wallet (Devnet Only)',
        name: 'autoFund',
        type: 'boolean',
        default: true,
        description: 'Automatically request USDC from Circle faucet when creating a new wallet on devnet. This provides initial USDC for payments. Disable if you prefer to fund manually.',
      },
    ],
  };

  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
    const items = this.getInputData();
    const returnData: INodeExecutionData[] = [];
    const mode = this.getNodeParameter('mode', 0) as string;

    // Get workflow static data to persist wallet across executions
    // Use 'node' scope - this persists per node instance in the workflow
    // NOTE: Workflow static data only persists if the workflow is SAVED in n8n
    const workflowData = this.getWorkflowStaticData('node');
    
    // Use a simple, consistent key for wallet storage
    const walletKey = 'pocketNodeWallet';
    
    // Get workflow info for diagnostics
    const workflow = this.getWorkflow();
    const workflowInfo = {
      id: workflow.id,
      name: workflow.name,
      active: workflow.active,
      // Check if workflow has an ID (saved workflows have IDs)
      isSaved: !!workflow.id && workflow.id !== 'unsaved'
    };
    
    // Warn if workflow is not saved
    if (!workflowInfo.isSaved) {
      console.warn('âš ï¸ Workflow appears to be unsaved. Workflow static data only persists for SAVED and ACTIVE workflows in n8n.');
      console.warn('âš ï¸ For testing: Save the workflow first (Ctrl/Cmd+S), then activate it. The auto-generated wallet will persist across executions only in active workflows.');
    }
    
    // Warn if workflow is saved but not active
    if (workflowInfo.isSaved && !workflowInfo.active) {
      console.warn('âš ï¸ Workflow is saved but not active. Workflow static data only persists for ACTIVE workflows in n8n.');
      console.warn('âš ï¸ The auto-generated wallet will NOT persist across executions. Activate the workflow (toggle switch) or use Pocket Node Wallet credential instead.');
      console.warn('âš ï¸ For manual testing: Activate the workflow, then execute. For persistent wallet without activation, use credentials.');
    }
    
    // Try to get wallet credentials, or use/generate persistent wallet
    let walletAddress: string;
    let privateKey: string;
    let network: 'devnet' | 'mainnet-beta';
    let isAutoGeneratedWallet = false;

    try {
    const credentials = await this.getCredentials('pocketNodeWallet');
      walletAddress = credentials.address as string;
      privateKey = credentials.privateKey as string;
      network = (credentials.network as 'devnet' | 'mainnet-beta') || 'devnet';
    } catch (error) {
      // No credentials provided - use or generate persistent wallet stored in workflow
      // Only check resetWallet parameter if mode is 'walletInfo' (where it's available)
      let resetWallet = false;
      try {
        resetWallet = (this.getNodeParameter('resetWallet', 0) as boolean) || false;
      } catch {
        // Parameter not available in this mode, ignore
      }
      
      // Try to get wallet from keyed storage first
      const storedWallet = workflowData[walletKey] as { address: string; privateKey: string; network: string; createdAt?: string } | undefined;
      
      // Fallback to direct properties for backward compatibility
      const existingWalletAddress = storedWallet?.address || (workflowData.walletAddress as string | undefined);
      const existingPrivateKey = storedWallet?.privateKey || (workflowData.privateKey as string | undefined);
      
      // Check if we should reset or if wallet doesn't exist
      const shouldCreateNew = resetWallet || !existingWalletAddress || !existingPrivateKey;
      
      if (shouldCreateNew) {
        // Generate new wallet and store it in workflow static data
        const tempWallet = generateWallet('devnet');
        
        // Store wallet data using a specific key for better persistence
        const walletData = {
          address: tempWallet.address,
          privateKey: tempWallet.privateKey,
          network: 'devnet',
          createdAt: new Date().toISOString()
        };
        
        // Store using the key
        workflowData[walletKey] = walletData;
        
        // Also store directly for backward compatibility
        workflowData.walletAddress = tempWallet.address;
        workflowData.privateKey = tempWallet.privateKey;
        workflowData.network = 'devnet';
        workflowData.createdAt = walletData.createdAt;
        
        walletAddress = tempWallet.address;
        privateKey = tempWallet.privateKey;
        network = 'devnet';
        isAutoGeneratedWallet = true;

        // Auto-fund wallet on devnet if enabled
        let autoFund = true; // Default to true
        try {
          autoFund = (this.getNodeParameter('autoFund', 0) as boolean) ?? true;
        } catch {
          // Parameter not available, use default
        }
        
        if (autoFund && network === 'devnet') {
          workflowData.autoFundRequested = true;
          workflowData.autoFundTimestamp = new Date().toISOString();
          
          // Actually request funding from faucets
          try {
            // Request SOL first
            console.log(`ðŸª™ Requesting SOL from Solana faucet for wallet: ${walletAddress}`);
            const solResponse = await fetch('https://faucet.solana.com/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                address: walletAddress,
                network: 'devnet',
              }),
            });
            
            const solResult = await solResponse.json();
            if (solResponse.ok) {
              console.log(`âœ… SOL requested successfully: ${JSON.stringify(solResult)}`);
              workflowData.solFunded = true;
              workflowData.solFundTimestamp = new Date().toISOString();
            } else {
              console.warn(`âš ï¸ SOL faucet request failed: ${JSON.stringify(solResult)}`);
              workflowData.solFundError = solResult.error || 'Unknown error';
            }
            
            // Wait a bit before requesting USDC
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Request USDC from Circle faucet
            console.log(`ðŸ’µ Requesting USDC from Circle faucet for wallet: ${walletAddress}`);
            const usdcResponse = await fetch('https://faucet.circle.com/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                address: walletAddress,
                network: 'devnet',
                asset: 'USDC',
              }),
            });
            
            const usdcResult = await usdcResponse.json();
            if (usdcResponse.ok) {
              console.log(`âœ… USDC requested successfully: ${JSON.stringify(usdcResult)}`);
              workflowData.usdcFunded = true;
              workflowData.usdcFundTimestamp = new Date().toISOString();
            } else {
              console.warn(`âš ï¸ USDC faucet request failed: ${JSON.stringify(usdcResult)}`);
              workflowData.usdcFundError = usdcResult.error || 'Unknown error';
            }
          } catch (error) {
            console.error(`âŒ Auto-fund error: ${error instanceof Error ? error.message : 'Unknown error'}`);
            workflowData.autoFundError = error instanceof Error ? error.message : 'Unknown error';
            // Don't throw - allow workflow to continue even if auto-fund fails
          }
        }
      } else {
        // Use existing stored wallet
        walletAddress = existingWalletAddress!;
        privateKey = existingPrivateKey!;
        network = (storedWallet?.network as 'devnet' | 'mainnet-beta') || ((workflowData.network as 'devnet' | 'mainnet-beta') || 'devnet');
        isAutoGeneratedWallet = true;
      }
    }

    // Initialize client with wallet
    const client = new X402Client({
      address: walletAddress,
      privateKey: privateKey,
      network: network,
    });

    // Helper function to get wallet info for all outputs
    const getWalletInfoOutput = async () => {
      const solBalance = await client.getBalance();
      return {
        walletAddress: walletAddress,
        network: network,
        solBalance: solBalance,
        isAutoGeneratedWallet: isAutoGeneratedWallet,
        fundingInstructions: isAutoGeneratedWallet 
          ? {
              message: 'This is an auto-generated wallet. Fund it with USDC and SOL to enable payments.',
              devnetFaucet: 'https://faucet.circle.com/',
              solFaucet: network === 'devnet' ? 'https://faucet.solana.com/' : null,
              walletAddress: walletAddress,
            }
          : {
              message: 'Using configured credential wallet.',
            },
      };
    };

    for (let i = 0; i < items.length; i++) {
      try {
        const inputData = items[i].json;

        if (mode === 'autoHandle') {
          // Auto-detect and handle 402 responses
          
          // Check if this is a 402 response
          const is402 = 
            inputData.statusCode === 402 || 
            inputData.x402Version !== undefined;

          if (!is402) {
            // Not a 402 response, pass through - but include wallet info so user knows the address
            const walletInfo = await getWalletInfoOutput();
            returnData.push({
              json: {
                ...inputData,
                _pocketNode: {
                  action: 'passthrough',
                  reason: 'Not a 402 response',
                  ...walletInfo,
                }
              },
              pairedItem: { item: i },
            });
            continue;
          }

          // This is a 402 response - auto-pay!
          const x402Response: X402Response = {
            x402Version: (inputData.x402Version as number) || 1,
            accepts: (inputData.accepts as any) || [],
            error: inputData.error as string | undefined,
          };

          // Check balances before attempting payment
          const solBalance = await client.getBalance();
          // Try to get payment amount from accepts array (may not always be available)
          const paymentRequirement = x402Response.accepts?.[0] as any;
          // maxAmountRequired is in smallest units (e.g., 10000 = 0.01 USDC if 6 decimals)
          // Convert to USDC units (divide by 1,000,000 for 6 decimals)
          const maxAmountRequired = paymentRequirement?.maxAmountRequired 
            ? parseFloat(paymentRequirement.maxAmountRequired) / 1000000 
            : 0;
          const requiredAmount = paymentRequirement?.amount || paymentRequirement?.value || maxAmountRequired;
          const usdcMint = paymentRequirement?.asset;
          let usdcBalance = 0;
          
          if (usdcMint) {
            try {
              usdcBalance = await client.getUSDCBalance(usdcMint);
            } catch (error) {
              // If we can't get USDC balance, we'll try anyway and let the payment fail with a better error
            }
          }

          // Only check USDC balance (SOL will be needed for fees but we'll let the transaction fail naturally if insufficient)
          if (requiredAmount > 0 && usdcBalance < requiredAmount) {
            const walletInfo = await getWalletInfoOutput();
            
            // For auto-generated wallets with zero balance, return wallet info instead of failing
            // This allows users to see the wallet address and fund it without the workflow failing
            if (isAutoGeneratedWallet && (usdcBalance === 0 || walletInfo.solBalance === 0)) {
              returnData.push({
                json: {
                  paymentRequired: true,
                  paymentStatus: 'insufficient_balance',
                  requiredAmount: requiredAmount,
                  currentBalance: {
                    usdc: usdcBalance,
                    sol: walletInfo.solBalance,
                  },
                  message: `Wallet needs funding before payment can be made.`,
                  fundingInstructions: {
                    walletAddress: walletAddress,
                    network: network,
                    steps: [
                      `1. Get USDC: https://faucet.circle.com/ (Solana Devnet)`,
                      `2. Get SOL: https://faucet.solana.com/ (Devnet)`,
                      `3. Send to wallet: ${walletAddress}`,
                      `4. Wait 10-30 seconds for confirmation, then retry this workflow.`,
                    ],
                  },
                  _pocketNode: {
                    action: 'wallet_needs_funding',
                    ...walletInfo,
                  },
                },
                pairedItem: { item: i },
              });
              continue;
            }
            
            // For credential wallets or if balance exists but is insufficient, throw error
            const errorMessage = `Insufficient USDC balance.\n\n` +
              `ðŸ’° WALLET ADDRESS: ${walletAddress}\n` +
              `Current Balance: ${usdcBalance} USDC\n` +
              `Required: ${requiredAmount} USDC\n` +
              `SOL Balance: ${walletInfo.solBalance} SOL\n\n` +
              `Note: SOL is required for transaction fees. Ensure you have SOL in addition to USDC.\n\n` +
              (isAutoGeneratedWallet 
                ? `ðŸ”§ FUND THIS WALLET:\n` +
                  `1. Get USDC: https://faucet.circle.com/ (Solana Devnet)\n` +
                  `2. Get SOL: https://faucet.solana.com/ (Devnet)\n` +
                  `3. Send to wallet: ${walletAddress}\n` +
                  `4. Wait 10-30 seconds for confirmation, then retry.`
                : `Fund your wallet with USDC and SOL, then retry.`);
            
            throw new NodeOperationError(
              this.getNode(),
              errorMessage,
              { itemIndex: i }
            );
          }

          // Make payment
          const paymentResult = await client.handleX402(x402Response);

          if (!paymentResult.success) {
            // Provide more helpful error messages
            let errorMessage = `Payment failed: ${paymentResult.error}`;
            let errorReason = 'payment_failed';
            const errorLower = paymentResult.error?.toLowerCase() || '';
            
            // Get wallet info for error messages
            const walletInfo = await getWalletInfoOutput();
            const solBalance = walletInfo.solBalance;
            
            // Check if it's a "no record of prior credit" error - means sender's token account doesn't exist
            if (errorLower.includes('no record of a prior credit') || errorLower.includes('no record of prior credit') || errorLower.includes('attempt to debit')) {
              errorReason = 'sender_token_account_missing';
              errorMessage = `Payment failed: USDC token account not found.\n\n` +
                `ðŸ’° WALLET ADDRESS: ${walletAddress}\n` +
                `Current Balance: ${usdcBalance} USDC | Required: ${requiredAmount} USDC\n` +
                `SOL Balance: ${solBalance} SOL\n\n` +
                `Note: SOL is required for transaction fees. Ensure you have SOL in addition to USDC.\n\n` +
                (isAutoGeneratedWallet 
                  ? `ðŸ”§ FUND THIS WALLET:\n` +
                    `1. Get USDC: https://faucet.circle.com/ (Solana Devnet)\n` +
                    `2. Get SOL: https://faucet.solana.com/ (Devnet)\n` +
                    `3. Send to wallet: ${walletAddress}\n` +
                    `4. Wait 10-30 seconds for confirmation, then retry.`
                  : `Fix: Receive USDC to this wallet first (creates token account). Wait 10-30 seconds, then retry.`);
            }
            // Check if it's an invalid account data error (USDC token account issue)
            else if (errorLower.includes('invalid account data') || errorLower.includes('invalidaccountdata')) {
              errorReason = 'invalid_usdc_account';
              errorMessage = `Payment failed: USDC token account issue.\n\n` +
                `ðŸ’° WALLET ADDRESS: ${walletAddress}\n` +
                `Current Balance: ${usdcBalance} USDC | Required: ${requiredAmount} USDC\n` +
                `SOL Balance: ${solBalance} SOL\n\n` +
                `Note: SOL is required for transaction fees. Ensure you have SOL in addition to USDC.\n\n` +
                (isAutoGeneratedWallet 
                  ? `ðŸ”§ FUND THIS WALLET:\n` +
                    `1. Get USDC: https://faucet.circle.com/ (Solana Devnet)\n` +
                    `2. Get SOL: https://faucet.solana.com/ (Devnet)\n` +
                    `3. Send to wallet: ${walletAddress}\n` +
                    `4. Wait 10-30 seconds for confirmation, then retry.`
                  : `Fix: Get USDC from https://faucet.circle.com/ (Solana Devnet) to wallet ${walletAddress}`);
            }
            // Check if it's a balance-related error
            else if (errorLower.includes('debit') || errorLower.includes('credit') || errorLower.includes('insufficient')) {
              errorReason = 'insufficient_balance';
              errorMessage = `Payment failed: ${paymentResult.error}\n\n` +
                `ðŸ’° WALLET ADDRESS: ${walletAddress}\n` +
                `Current Balance: ${usdcBalance} USDC | Required: ${requiredAmount} USDC\n` +
                `SOL Balance: ${solBalance} SOL\n\n` +
                `Note: SOL is required for transaction fees. Ensure you have SOL in addition to USDC.\n\n` +
                (isAutoGeneratedWallet 
                  ? `ðŸ”§ FUND THIS WALLET:\n` +
                    `1. Get USDC: https://faucet.circle.com/ (Solana Devnet)\n` +
                    `2. Get SOL: https://faucet.solana.com/ (Devnet)\n` +
                    `3. Send to wallet: ${walletAddress}\n` +
                    `4. Wait 10-30 seconds for confirmation, then retry.`
                  : `Fix: Get USDC from https://faucet.circle.com/ (Solana Devnet)`);
            }
            // Generic error with context
            else {
              errorMessage = `Payment failed: ${paymentResult.error}\n\n` +
                `ðŸ’° WALLET ADDRESS: ${walletAddress}\n` +
                `Current Balance: ${usdcBalance} USDC | Required: ${requiredAmount} USDC\n` +
                `SOL Balance: ${solBalance} SOL\n\n` +
                `Note: SOL is required for transaction fees. Ensure you have SOL in addition to USDC.\n\n` +
                (isAutoGeneratedWallet 
                  ? `ðŸ”§ FUND THIS WALLET:\n` +
                    `1. Get USDC: https://faucet.circle.com/ (Solana Devnet)\n` +
                    `2. Get SOL: https://faucet.solana.com/ (Devnet)\n` +
                    `3. Send to wallet: ${walletAddress}\n` +
                    `4. Wait 10-30 seconds for confirmation, then retry.`
                  : `Fix: Get USDC from https://faucet.circle.com/ (Solana Devnet)`);
            }
            
            // Throw error - workflow fails
            throw new NodeOperationError(
              this.getNode(),
              errorMessage,
              { itemIndex: i }
            );
          }

          // Create payment header
          const paymentHeader = client.createPaymentHeader(paymentResult.signature!);
          const walletInfo = await getWalletInfoOutput();

          returnData.push({
            json: {
              paymentMade: true,
              signature: paymentResult.signature,
              amount: paymentResult.amount,
              recipient: paymentResult.recipient,
              paymentHeader: paymentHeader,
              originalRequest: {
                resource: x402Response.accepts[0]?.resource,
                description: x402Response.accepts[0]?.description,
              },
              _pocketNode: {
                action: 'payment_completed',
                ...walletInfo,
              },
            },
            pairedItem: { item: i },
          });

        } else if (mode === 'walletInfo') {
          // Get wallet info and balances
          const walletInfo = await getWalletInfoOutput();
          
          let usdcBalance = 0;
          if (inputData.x402Version && inputData.accepts?.[0]?.asset) {
            try {
              usdcBalance = await client.getUSDCBalance(inputData.accepts[0].asset);
            } catch (error) {
              // USDC balance might not be available if token account doesn't exist
            }
          }

          returnData.push({
            json: {
              address: walletAddress,
              network: network,
              balances: {
                sol: walletInfo.solBalance,
                usdc: usdcBalance,
              },
              _pocketNode: walletInfo,
            },
            pairedItem: { item: i },
          });
        }

      } catch (error) {
        if (this.continueOnFail()) {
          // Include wallet info in error output so user can see the address even on failure
          try {
            const walletInfo = await getWalletInfoOutput();
            returnData.push({
              json: {
                error: error instanceof Error ? error.message : 'Unknown error',
                _pocketNode: {
                  action: 'error',
                  ...walletInfo,
                },
              },
              pairedItem: { item: i },
            });
          } catch (walletError) {
            // If we can't get wallet info, just return the error
            returnData.push({
              json: {
                error: error instanceof Error ? error.message : 'Unknown error',
                _pocketNode: {
                  action: 'error',
                  walletAddress: walletAddress,
                  isAutoGeneratedWallet: isAutoGeneratedWallet,
                },
              },
              pairedItem: { item: i },
            });
          }
          continue;
        }
        throw error;
      }
    }

    return [returnData];
  }
}